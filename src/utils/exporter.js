// Utilities to produce sample frames and convert frames to Arduino C arrays
import { mirrorX, mirrorY } from './drawHelpers.js';

export function framesToCArray(frames, name) {
  if (!frames || frames.length === 0) return '// no frames';

  // Apply mirroring transformations to match physical cube orientation
  const transformedFrames = frames.map((frame) => mirrorX(frame));

  const frameCount = transformedFrames.length;
  const cols = 64;
  let out = `// Generated by LED Cube Designer\n#define ${name}_FRAME_COUNT ${frameCount}\n\nconst byte ${name}[${frameCount}][${cols}] = {\n`;

  transformedFrames.forEach((f, fi) => {
    out += `  // Frame ${fi}\n  {`;
    for (let i = 0; i < cols; i++) {
      const v = f[i] || 0;
      out += '0x' + v.toString(16).toUpperCase().padStart(2, '0');
      if (i < cols - 1) out += ', ';
      if ((i + 1) % 8 === 0 && i < cols - 1) out += '\n   ';
    }
    out += '}';
    if (fi < frameCount - 1) out += ',\n\n';
    else out += '\n';
  });

  out += '};\n';
  return out;
}

// Provide simple frames for J, A, N as examples (very small shapes centered)
export function framesForJAN() {
  // start with blanks
  const blank = new Array(64).fill(0x00);
  const J = blank.slice();
  const A = blank.slice();
  const N = blank.slice();

  // Example patterns (coarse) - set some columns
  // J: vertical on right columns and hook at bottom
  J[8 * 2 + 5] = 0x7e;
  J[8 * 3 + 5] = 0x7e;
  J[8 * 2 + 2] = 0x80;
  J[8 * 2 + 3] = 0x80;
  J[8 * 2 + 4] = 0x80;
  J[8 * 2 + 5] = 0x7e;

  // A: vertical sides and crossbar
  A[8 * 3 + 2] = 0xfe;
  A[8 * 4 + 2] = 0xfe;
  A[8 * 3 + 5] = 0xfe;
  A[8 * 4 + 5] = 0xfe;
  A[8 * 2 + 3] = 0x80;
  A[8 * 2 + 4] = 0x80;
  A[8 * 4 + 3] = 0x10;
  A[8 * 4 + 4] = 0x10;

  // N: left and right, diagonal
  N[8 * 3 + 2] = 0xfe;
  N[8 * 4 + 2] = 0xfe;
  N[8 * 3 + 5] = 0xfe;
  N[8 * 4 + 5] = 0xfe;
  N[8 * 3 + 3] = 0x42;
  N[8 * 4 + 4] = 0x24;

  return [J, A, N];
}

export function generateHFile(name, frames) {
  const arr = framesToCArray(frames, name);
  const guard = `_${name}_H_`.toUpperCase();
  let out =
    `#ifndef ${guard}\n#define ${guard}\n\n#include <Arduino.h>\n\n` +
    arr +
    `\n#endif // ${guard}\n`;
  return out;
}

export function generateSketch(name, frames) {
  // generate the C array text first
  let arr = framesToCArray(frames, name);

  // replace the array declaration to place it in flash (PROGMEM)
  const header = `const byte ${name}[${frames.length}][64] = {`;
  const headerProg = `const byte ${name}[${frames.length}][64] PROGMEM = {`;
  arr = arr.replace(header, headerProg);

  // sketch template using PROGMEM and pgm_read_byte
  const sketch = `// Generated Arduino sketch for ${name}\n\n#include <Arduino.h>\n#include <avr/pgmspace.h>\n\n${arr}\n\n// send one frame stored in PROGMEM (framePtr points to 64 bytes)\nvoid sendFrameFromPROGMEM(const uint8_t *framePtr) {\n  Serial.write(0xF2);\n  for (int i = 0; i < 64; i++) {\n    uint8_t b = pgm_read_byte(framePtr + i);\n    Serial.write(b);\n  }\n}\n\nvoid setup(){\n  Serial.begin(38400);\n  delay(500);\n  // send open command\n  for(int i=0;i<70;i++) Serial.write(0xAD);\n  delay(200);\n}\n\nvoid loop(){\n  for (int f = 0; f < ${name}_FRAME_COUNT; f++) {\n    const uint8_t *framePtr = ${name}[f];\n    sendFrameFromPROGMEM(framePtr);\n    delay(200);\n  }\n  // keep looping\n}\n`;

  return sketch;
}

// Generate a receiver sketch that accepts frames over Serial with checksum/ACK
export function generateStreamingReceiverSketch() {
  const sketch = `// Streaming receiver sketch for LED Cube - receives frames over Serial\n\n#include <Arduino.h>\n\nconst uint8_t FRAME_MARKER = 0xF2;\nconst uint8_t ACK = 0xAA;\nconst uint8_t NACK = 0xFF;\n\n// Replace this with your cube display function.\nvoid displayFrame(const uint8_t *frame) {\n  // TODO: map 64-byte frame into your cube wiring and update outputs\n  // Example placeholder: blink onboard LED to indicate frame received\n  digitalWrite(LED_BUILTIN, HIGH);\n  delay(20);\n  digitalWrite(LED_BUILTIN, LOW);\n}\n\nvoid setup() {\n  Serial.begin(38400);\n  pinMode(LED_BUILTIN, OUTPUT);\n}\n\nvoid loop() {\n  if (Serial.available() <= 0) return;\n  int c = Serial.read();\n  if (c != FRAME_MARKER) return;\n\n  // read 64 bytes for frame\n  uint8_t buf[64];\n  unsigned long start = millis();\n  int got = 0;\n  while (got < 64 && (millis() - start) < 1000) {\n    if (Serial.available() > 0) {\n      int v = Serial.read();\n      if (v >= 0) buf[got++] = (uint8_t)v;\n    }
  }
  if (got < 64) {\n+    Serial.write(NACK);\n+    return;\n+  }\n+\n+  // read checksum\n+  start = millis();\n+  while (Serial.available() == 0 && (millis() - start) < 500) ;\n+  if (Serial.available() == 0) {\n+    Serial.write(NACK);\n+    return;\n+  }\n+  uint8_t checksum = (uint8_t)Serial.read();\n+\n+  uint8_t sum = 0;\n+  for (int i = 0; i < 64; i++) sum += buf[i];\n+  if (sum != checksum) {\n+    Serial.write(NACK);\n+    return;\n+  }\n+\n+  // valid frame - acknowledge and display\n+  Serial.write(ACK);\n+  displayFrame(buf);\n+}\n+`;

  return sketch;
}

// ========== TEXT & GLYPH ANIMATION ==========

// Simple 5x7 font (columns, LSB = top row)
const FONT5x7 = {
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00],
  A: [0x7c, 0x12, 0x11, 0x12, 0x7c],
  B: [0x7f, 0x49, 0x49, 0x49, 0x36],
  C: [0x3e, 0x41, 0x41, 0x41, 0x22],
  D: [0x7f, 0x41, 0x41, 0x22, 0x1c],
  E: [0x7f, 0x49, 0x49, 0x49, 0x41],
  F: [0x7f, 0x09, 0x09, 0x09, 0x01],
  G: [0x3e, 0x41, 0x49, 0x49, 0x7a],
  H: [0x7f, 0x08, 0x08, 0x08, 0x7f],
  I: [0x00, 0x41, 0x7f, 0x41, 0x00],
  J: [0x20, 0x40, 0x41, 0x3f, 0x01],
  K: [0x7f, 0x08, 0x14, 0x22, 0x41],
  L: [0x7f, 0x40, 0x40, 0x40, 0x40],
  M: [0x7f, 0x02, 0x04, 0x02, 0x7f],
  N: [0x7f, 0x04, 0x08, 0x10, 0x7f],
  O: [0x3e, 0x41, 0x41, 0x41, 0x3e],
  P: [0x7f, 0x09, 0x09, 0x09, 0x06],
  Q: [0x3e, 0x41, 0x51, 0x21, 0x5e],
  R: [0x7f, 0x09, 0x19, 0x29, 0x46],
  S: [0x46, 0x49, 0x49, 0x49, 0x31],
  T: [0x01, 0x01, 0x7f, 0x01, 0x01],
  U: [0x3f, 0x40, 0x40, 0x40, 0x3f],
  V: [0x1f, 0x20, 0x40, 0x20, 0x1f],
  W: [0x7f, 0x20, 0x18, 0x20, 0x7f],
  X: [0x63, 0x14, 0x08, 0x14, 0x63],
  Y: [0x03, 0x04, 0x78, 0x04, 0x03],
  Z: [0x61, 0x51, 0x49, 0x45, 0x43],
  0: [0x3e, 0x45, 0x49, 0x51, 0x3e],
  1: [0x00, 0x21, 0x7f, 0x01, 0x00],
  2: [0x23, 0x45, 0x49, 0x49, 0x31],
  3: [0x22, 0x41, 0x49, 0x49, 0x36],
  4: [0x0c, 0x14, 0x24, 0x7f, 0x04],
  5: [0x72, 0x51, 0x51, 0x51, 0x4e],
  6: [0x3e, 0x49, 0x49, 0x49, 0x26],
  7: [0x40, 0x47, 0x48, 0x50, 0x60],
  8: [0x36, 0x49, 0x49, 0x49, 0x36],
  9: [0x32, 0x49, 0x49, 0x49, 0x3e],
  '!': [0x00, 0x00, 0x5f, 0x00, 0x00],
  '?': [0x20, 0x40, 0x4d, 0x50, 0x20],
  '-': [0x08, 0x08, 0x08, 0x08, 0x08],
  _: [0x40, 0x40, 0x40, 0x40, 0x40],
  '.': [0x00, 0x60, 0x60, 0x00, 0x00],
  ',': [0x00, 0x80, 0x60, 0x00, 0x00],
  ':': [0x00, 0x36, 0x36, 0x00, 0x00],
  ';': [0x00, 0x80, 0x36, 0x00, 0x00],
  '+': [0x08, 0x08, 0x3e, 0x08, 0x08],
  '=': [0x14, 0x14, 0x14, 0x14, 0x14],
  '<': [0x08, 0x14, 0x22, 0x41, 0x00],
  '>': [0x00, 0x41, 0x22, 0x14, 0x08],
  '/': [0x60, 0x10, 0x08, 0x04, 0x03],
  '\\': [0x03, 0x04, 0x08, 0x10, 0x60],
  '(': [0x00, 0x1c, 0x22, 0x41, 0x00],
  ')': [0x00, 0x41, 0x22, 0x1c, 0x00],
  '[': [0x00, 0x7f, 0x41, 0x41, 0x00],
  ']': [0x00, 0x41, 0x41, 0x7f, 0x00],
  '{': [0x00, 0x08, 0x36, 0x41, 0x00],
  '}': [0x00, 0x41, 0x36, 0x08, 0x00],
  '*': [0x14, 0x08, 0x3e, 0x08, 0x14],
  '#': [0x24, 0x7e, 0x24, 0x7e, 0x24],
  '@': [0x3e, 0x41, 0x5d, 0x55, 0x5e],
  '&': [0x36, 0x49, 0x55, 0x22, 0x50],
  '%': [0x62, 0x64, 0x08, 0x13, 0x23],
  $: [0x24, 0x2a, 0x7f, 0x2a, 0x12],
  '^': [0x04, 0x02, 0x01, 0x02, 0x04],
  '~': [0x02, 0x01, 0x02, 0x04, 0x02],
  '`': [0x00, 0x01, 0x02, 0x00, 0x00],
  "'": [0x00, 0x00, 0x07, 0x00, 0x00],
  '"': [0x00, 0x07, 0x00, 0x07, 0x00],
  '|': [0x00, 0x00, 0x7f, 0x00, 0x00],
};

// Custom font designed specifically for 8x8x8 cube 3D spinning
// Each letter is 5 columns wide, 7 pixels tall, perfectly centered for rotation
// Optimized for readability when spinning in 3D space
const CUBE8x8_FONT = {
  ' ': [0x00, 0x00, 0x00, 0x00, 0x00],

  // Vowels - extra clear for readability
  A: [0x3e, 0x09, 0x09, 0x09, 0x3e], // Simplified A
  E: [0x7f, 0x49, 0x49, 0x49, 0x41], // Clear E
  I: [0x00, 0x41, 0x7f, 0x41, 0x00], // Centered I
  O: [0x3e, 0x41, 0x41, 0x41, 0x3e], // Perfect O
  U: [0x3f, 0x40, 0x40, 0x40, 0x3f], // Clean U

  // Consonants - optimized for 3D visibility
  B: [0x7f, 0x49, 0x49, 0x49, 0x36], // Bold B
  C: [0x3e, 0x41, 0x41, 0x41, 0x22], // Open C
  D: [0x7f, 0x41, 0x41, 0x22, 0x1c], // Rounded D
  F: [0x7f, 0x09, 0x09, 0x09, 0x01], // Strong F
  G: [0x3e, 0x41, 0x49, 0x49, 0x3a], // Clear G
  H: [0x7f, 0x08, 0x08, 0x08, 0x7f], // Balanced H
  J: [0x20, 0x40, 0x41, 0x3f, 0x01], // Hooked J
  K: [0x7f, 0x08, 0x14, 0x22, 0x41], // Angular K
  L: [0x7f, 0x40, 0x40, 0x40, 0x40], // Simple L
  M: [0x7f, 0x02, 0x0c, 0x02, 0x7f], // Wide M
  N: [0x7f, 0x04, 0x08, 0x10, 0x7f], // Diagonal N
  P: [0x7f, 0x09, 0x09, 0x09, 0x06], // Compact P
  Q: [0x3e, 0x41, 0x51, 0x21, 0x5e], // Tailed Q
  R: [0x7f, 0x09, 0x19, 0x29, 0x46], // Legged R
  S: [0x26, 0x49, 0x49, 0x49, 0x32], // Curved S
  T: [0x01, 0x01, 0x7f, 0x01, 0x01], // Centered T
  V: [0x1f, 0x20, 0x40, 0x20, 0x1f], // Pointed V
  W: [0x3f, 0x40, 0x20, 0x40, 0x3f], // Double V
  X: [0x63, 0x14, 0x08, 0x14, 0x63], // Cross X
  Y: [0x03, 0x04, 0x78, 0x04, 0x03], // Forked Y
  Z: [0x61, 0x51, 0x49, 0x45, 0x43], // Zigzag Z

  // Numbers - clear and distinct
  0: [0x3e, 0x51, 0x49, 0x45, 0x3e], // Slashed 0
  1: [0x00, 0x42, 0x7f, 0x40, 0x00], // Simple 1
  2: [0x42, 0x61, 0x51, 0x49, 0x46], // Clear 2
  3: [0x21, 0x41, 0x49, 0x4d, 0x33], // Curved 3
  4: [0x18, 0x14, 0x12, 0x7f, 0x10], // Angled 4
  5: [0x27, 0x45, 0x45, 0x45, 0x39], // Squared 5
  6: [0x3c, 0x4a, 0x49, 0x49, 0x30], // Rounded 6
  7: [0x01, 0x71, 0x09, 0x05, 0x03], // Slanted 7
  8: [0x36, 0x49, 0x49, 0x49, 0x36], // Double 8
  9: [0x06, 0x49, 0x49, 0x29, 0x1e], // Flipped 6

  // Special characters
  '!': [0x00, 0x00, 0x5f, 0x00, 0x00],
  '?': [0x02, 0x01, 0x51, 0x09, 0x06],
  '.': [0x00, 0x60, 0x60, 0x00, 0x00],
  '-': [0x08, 0x08, 0x08, 0x08, 0x08],
  '+': [0x08, 0x08, 0x3e, 0x08, 0x08],
  '*': [0x14, 0x08, 0x3e, 0x08, 0x14],
  '/': [0x60, 0x10, 0x08, 0x04, 0x03],
  '\\': [0x03, 0x04, 0x08, 0x10, 0x60],
  '(': [0x00, 0x1c, 0x22, 0x41, 0x00],
  ')': [0x00, 0x41, 0x22, 0x1c, 0x00],
  '[': [0x00, 0x7f, 0x41, 0x41, 0x00],
  ']': [0x00, 0x41, 0x41, 0x7f, 0x00],
  ':': [0x00, 0x36, 0x36, 0x00, 0x00],
  ';': [0x00, 0x56, 0x36, 0x00, 0x00],
  '<': [0x08, 0x14, 0x22, 0x41, 0x00],
  '>': [0x00, 0x41, 0x22, 0x14, 0x08],
  '=': [0x14, 0x14, 0x14, 0x14, 0x14],
  '#': [0x14, 0x7f, 0x14, 0x7f, 0x14],
  '@': [0x3e, 0x41, 0x5d, 0x55, 0x5e],
  '&': [0x36, 0x49, 0x55, 0x22, 0x50],
  '%': [0x23, 0x13, 0x08, 0x64, 0x62],
  $: [0x24, 0x2a, 0x7f, 0x2a, 0x12],
  '^': [0x04, 0x02, 0x01, 0x02, 0x04],
  '~': [0x02, 0x01, 0x02, 0x04, 0x02],
  '`': [0x00, 0x01, 0x02, 0x04, 0x00],
  "'": [0x00, 0x00, 0x07, 0x00, 0x00],
  '"': [0x00, 0x07, 0x00, 0x07, 0x00],
  '|': [0x00, 0x00, 0x7f, 0x00, 0x00],
  _: [0x40, 0x40, 0x40, 0x40, 0x40],
  ',': [0x00, 0x80, 0x60, 0x00, 0x00],
};

// Helper: flip font column bits vertically (fix upside-down letters)
function flipColumnVertical(col) {
  let flipped = 0;
  for (let z = 0; z < 7; z++) {
    if ((col >> z) & 1) {
      flipped |= 1 << (6 - z);
    }
  }
  return flipped;
}

// Helper: set a column at a specific position on the cube
// Updated to match physical cube orientation - flip vertically for proper letter orientation
// position goes from 0-31 for a 4-sided wrap (8 positions per side)
// position 0-7: front face (y=7, x=0-7)
// position 8-15: right face (x=7, y=7-0)
// position 16-23: back face (y=0, x=7-0)
// position 24-31: left face (x=0, y=0-7)
function setColumnAtPosition(frame, col, position) {
  // Flip the column vertically so letters appear right-side up
  const finalCol = flipColumnVertical(col);

  let mask = 0;
  for (let z = 0; z < 7; z++) {
    if ((finalCol >> z) & 1) mask |= 1 << z;
  }

  if (position >= 0 && position < 8) {
    // Front face: y=7, x=position
    frame[8 * 7 + position] = mask;
  } else if (position >= 8 && position < 16) {
    // Right face: x=7, y=7-(position-8)
    const y = 7 - (position - 8);
    frame[8 * y + 7] = mask;
  } else if (position >= 16 && position < 24) {
    // Back face: y=0, x=7-(position-16)
    const x = 7 - (position - 16);
    frame[8 * 0 + x] = mask;
  } else if (position >= 24 && position < 32) {
    // Left face: x=0, y=position-24
    const y = position - 24;
    frame[8 * y + 0] = mask;
  }
}

// Scroll text continuously around specified number of sides. Returns array of frames.
// sides: number of sides (1-4) to use for scrolling
// direction: 'ltr' (default) or 'rtl' (render columns for right-to-left preview)
export function generateTextFrames(text = '', sides = 1, direction = 'ltr') {
  const t = String(text || '').toUpperCase();
  if (!t) return [];

  // Build column buffer - forward order to match physical cube direction
  const cols = [];

  // Build in forward order (this will make it scroll in the correct direction)
  for (let i = 0; i < t.length; i++) {
    const ch = t[i];
    const glyph = FONT5x7[ch] || FONT5x7[' '];
    cols.push(0x00); // spacing
    // Add columns in forward order
    for (let ci = 0; ci < glyph.length; ci++) {
      cols.push(glyph[ci]);
    }
  }

  const padding = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
  const buffer = padding.concat(cols).concat(padding);

  // Total positions available based on number of sides
  const positionsPerSide = 8;
  const totalPositions = sides * positionsPerSide;

  const frames = [];

  // Create frames where text flows continuously around the sides
  // We need enough frames to scroll the entire buffer through the visible window
  const numFrames = buffer.length + totalPositions;

  for (let frameIdx = 0; frameIdx < numFrames; frameIdx++) {
    const frame = new Array(64).fill(0x00);

    // For this frame, render columns at each visible position
    for (let pos = 0; pos < totalPositions; pos++) {
      // Reverse the buffer index calculation to change scroll direction
      const bufferIndex = frameIdx + pos - totalPositions;

      if (bufferIndex >= 0 && bufferIndex < buffer.length) {
        const col = buffer[bufferIndex];
        setColumnAtPosition(frame, col, pos);
      }
    }

    frames.push(frame);
  }

  return frames;
}

// Render glyph columns to a specific face with optional thickness
function renderColumnsToFace(glyph, face = 'front', thickness = 1) {
  const frame = new Array(64).fill(0x00);

  for (let cx = 0; cx < Math.min(5, glyph.length); cx++) {
    const col = flipColumnVertical(glyph[cx] || 0);

    // Center the glyph horizontally
    const x = cx + 1; // This centers a 5-wide glyph in 8-wide space

    let mask = 0;
    for (let z = 0; z < 7; z++) {
      if ((col >> z) & 1) {
        mask |= 1 << z;
      }
    }

    if (face === 'front') {
      // Place on front face (y = 7) and optionally one layer back for thickness
      frame[8 * 7 + x] = mask;
      if (thickness > 1) {
        frame[8 * 6 + x] = mask; // One layer back
      }
    }
    // Add other faces if needed
  }

  return frame;
}

// Render a single glyph and produce animated frames
import { rotateZ90 } from './drawHelpers.js';

export function generateGlyphFrames(char = 'A', steps = 4, mode = 'flat') {
  const ch = String(char || ' ').toUpperCase();

  if (mode === '3d') {
    // True 3D center spin: render readable glyph in 3D space using CUBE8x8_FONT
    return generate3DGlyphSpin(ch, steps);
  } else {
    // Flat rotation on front face using standard FONT5x7
    const glyph = FONT5x7[ch] || FONT5x7[' '];
    const base = renderColumnsToFace(glyph, 'front', 2);
    const res = [base];
    let cur = base;
    for (let s = 1; s < steps; s++) {
      cur = rotateZ90(cur);
      res.push(cur.slice());
    }
    return res;
  }
}

// Generate 3D spinning glyph in center of cube - TRUE 3D rotation with readable letters
function generate3DGlyphSpin(glyph, steps) {
  const frames = [];

  // Use the new CUBE8x8_FONT for optimal 3D display
  const charPattern = CUBE8x8_FONT[glyph.toUpperCase()] || CUBE8x8_FONT[' '];

  for (let step = 0; step < steps; step++) {
    const frame = new Array(64).fill(0x00);
    const angle = (step / steps) * Math.PI * 2;

    // Perfect 8x8x8 cube centering
    const CUBE_SIZE = 8;
    const CHAR_WIDTH = 5;
    const CHAR_HEIGHT = 7;

    // Mathematical center of 8x8x8 cube (index 3.5, use 4 for integer grid)
    const centerX = 4;
    const centerY = 4;
    const centerZ = 4;

    // Character bounds relative to center
    const charStartX = centerX - Math.floor(CHAR_WIDTH / 2); // 2
    const charStartY = centerY - Math.floor(CHAR_HEIGHT / 2); // 1

    for (let col = 0; col < CHAR_WIDTH; col++) {
      const columnData = charPattern[col];

      for (let row = 0; row < CHAR_HEIGHT; row++) {
        if (columnData & (1 << row)) {
          // Character position in cube space (before rotation)
          const charX = col - Math.floor(CHAR_WIDTH / 2); // -2 to +2 (horizontal position)
          const charY = 0; // Start at center depth
          const charZ = (CHAR_HEIGHT - 1) - row; // Flip vertically: row 0 becomes top, row 6 becomes bottom

          // Apply Z-axis rotation (spinning around vertical Z-axis, keeping letters upright)
          const cosAngle = Math.cos(angle);
          const sinAngle = Math.sin(angle);

          // Rotate around Z-axis: X and Y change, Z stays the same (upright)
          const rotatedX = charX * cosAngle - charY * sinAngle;
          const rotatedY = charX * sinAngle + charY * cosAngle;

          // Convert to cube coordinates
          const cubeX = Math.round(centerX + rotatedX);
          const cubeY = Math.round(centerY + rotatedY);
          const cubeZ = charStartY + charZ; // Z is the vertical axis (now properly flipped)

          // Draw character 2 layers thick for 3D visibility
          for (let thickness = 0; thickness < 2; thickness++) {
            const finalCubeY = cubeY + (thickness - 0.5); // Center the thickness around rotation
            const finalY = Math.round(finalCubeY);

            // Bounds checking
            if (
              cubeX >= 0 &&
              cubeX < CUBE_SIZE &&
              finalY >= 0 &&
              finalY < CUBE_SIZE &&
              cubeZ >= 0 &&
              cubeZ < CUBE_SIZE
            ) {
              const byteIndex = CUBE_SIZE * finalY + cubeX;
              if (byteIndex >= 0 && byteIndex < 64) {
                frame[byteIndex] |= 1 << cubeZ;
              }
            }
          }
        }
      }
    }

    frames.push(frame);
  }

  return frames;
}
